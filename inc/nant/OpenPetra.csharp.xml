<?xml version="1.0"?>
<project name="OpenPetra-csharp">

<include buildfile="OpenPetra.default.targets.xml"/>


<include buildfile="OpenPetra.references.xml"/>

<property name="RunCsDepend" value="true" overwrite="false"/>
<property name="OutputType" value="library" overwrite="false"/>
<property name="csc-ouput-ext" value="dll" if="${OutputType=='library'}" />
<property name="csc-ouput-ext" value="exe" unless="${OutputType=='library'}" />
<property name="AssemblyName" value="${Namespace}.${csc-ouput-ext}" />
<property name="namespace-temp-dir" value="${path::combine(dir.bin,Namespace)}" />
<property name="AssemblyNameInfo.cs" value="${path::combine(namespace-temp-dir,'AssemblyInfo.cs')}" />
<property name="referencesFile" value="${path::combine(namespace-temp-dir,Namespace+'.generated.refs')}" />
<property name="compilefiles" value="*.cs"  overwrite="false"/>
<property name="excludecsfiles" value=".doc"  overwrite="false"/>


<target name="clean" >
  <delete>
    <fileset>
      <include name="${dir.bin}/${AssemblyName}" asis="true" />
      <include name="${dir.bin}/${Namespace}.xml" asis="true" />
      <include name="${dir.bin}/${Namespace}.pdb" asis="true" />
    </fileset>
  </delete>
</target>

<if test="${not target::exists('custdepend')}">
  <include buildfile="OpenPetra.target-custdepend.xml"/>
</if>

<target name="depend" depends="custdepend">
  <if test="${true==bool::parse(RunCsDepend)}">
    <mkdir dir="${namespace-temp-dir}" />
     <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('CsDepend')}"/>
    <CsDepend ns-default="${Namespace}" ns-exceptions="${csdependNamespaceExceptions}" 
      basedir="${project::get-base-directory()}"
      referencesfile="${referencesFile}" buildincfile="${path::combine(dir.buildfiles, 'OpenPetra.csharp.xml')}">
      <sources>
        <include name="**/*.cs" />
        <exclude name="${excludecsfiles}" />
      </sources>    
    </CsDepend>
    <include buildfile="${referencesFile}" />
  </if>
  <assemblyfileset id="assemblyfileset-references">
    <!-- duplicated below. References are set after the include -->
    <lib>
      <include name="${dir.bin}"/>
    </lib>
    <patternset refid="references" />
    <patternset refid="csharpStdLibs" />
  </assemblyfileset>
</target>

<target name="compile" depends="depend">
  <!-- Create assembly info -->
  <mkdir dir="${namespace-temp-dir}" />

  <if test="${bool::parse(RunCsDepend)!=true}">
    <asminfo output="${AssemblyNameInfo.cs}" language="CSharp">
      <imports>
        <import namespace="System.Reflection" />
        <import namespace="System.Runtime.CompilerServices" />
        <import namespace="System.Runtime.InteropServices" />
      </imports>
      <attributes>
        <attribute type="AssemblyTitle" value='"${Namespace}"' asis="true" />
        <attribute type="AssemblyDescription" value='""' asis="true" />
        <attribute type="AssemblyConfiguration" value='""' asis="true" />
        <attribute type="AssemblyCompany" value='"ICT"' asis="true" />
        <attribute type="AssemblyProduct" value='"OpenPetra"' asis="true" />
        <attribute type="AssemblyCopyright" value='"(c) OM International 2004-2011"' asis="true" />
        <attribute type="AssemblyTrademark" value='""' asis="true" />
        <attribute type="AssemblyCulture" value='""' asis="true" />       
        <attribute type="ComVisible" value="false" asis="true" /> 
        <attribute type="AssemblyVersion" value='"0.0.9.0"' asis="true" /> 
      </attributes>
    </asminfo>
    <csc filealign="4096" output="${dir.bin}/${AssemblyName}" 
         doc="${dir.bin}/${Namespace}.xml"
         target="${OutputType}" debug="${compile.debug}" 
         noconfig="true">
      <references refid="assemblyfileset-references" /> 
      <sources>
        <include name="${compilefiles}" />
        <include name="${AssemblyNameInfo.cs}" />
      </sources>
      <resources>
        <include name="*.resx" />
      </resources>
    </csc>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="compile" />
    <call target="nant-subcall" cascade="false" />
  </if>
  
</target>

<target name="generateCsproject" depends="generate-csproject-sharpdevelop">
</target>

<target name="generate-csproject-sharpdevelop">
  <property name="devenv-name" value="sharpdevelop" />
  <call target="generate-csproject-internal" />
</target>


<target name="generate-csproject-internal" depends="depend">
  <!-- Add cs and resx files -->
  <property name="templatedir" value="${path::combine(dir.incdir.template, devenv-name)}" />

  <property name="TemplateReferences" value="" />
  <property name="TemplateProjectReferences" value="" />
  <foreach item="File" property="reference-path">
    <in>
      <items refid="assemblyfileset-references" />
    </in>
    <do>  
      <!-- Extract reference name from the reference path-->
      <property name="reference-name" 
                value="${path::get-file-name-without-extension(reference-path)}" />
      <property name="reference-project-file"
                value="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, reference-name+'.csproj'))}" />           
      <if test="${file::exists(reference-project-file)}">
        <!-- Reference to another project. Find GUID -->
        <xmlpeek
            file="${reference-project-file}"
            xpath="/*[local-name()='Project']/*[local-name()='PropertyGroup']/*[local-name()='ProjectGuid']"
            property="reference-project-guid"/>
        <loadfile file="${path::combine(templatedir, 'template.csproj.projectreference')}"
                  property="tempTemplateReferences" encoding="utf-8">  
          <filterchain>
            <expandproperties />
          </filterchain>
        </loadfile>
        <property name="TemplateProjectReferences" value="${TemplateProjectReferences}${tempTemplateReferences}" />
      </if>
      <if test="${not file::exists(reference-project-file)}">
        <loadfile file="${path::combine(templatedir, 'template.csproj.reference')}"
                  property="tempTemplateReferences" encoding="utf-8">  
          <filterchain>
            <expandproperties />
          </filterchain>
        </loadfile>
        <property name="TemplateReferences" value="${TemplateReferences}${tempTemplateReferences}" />
      </if>
    </do>
  </foreach>    

  <property name="TemplateResource" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="**/*.resx" />
      </items>
    </in>
    <do>
    <property name="DependentUpon" value="${path::change-extension(filename,'.cs')}" />
    <property name="template" value="template.csproj.resource" />
    <if test="${file::exists(DependentUpon)}">
      <property name="template" value="template.csproj.resource.DependentUpon" />
    </if>
    <loadfile file="${path::combine(templatedir, template)}"
              property="tempTemplateResource" encoding="utf-8">  
      <filterchain>
        <expandproperties />
      </filterchain>
    </loadfile>
    <property name="TemplateResource" value="${TemplateResource}${tempTemplateResource}" />
    </do>
  </foreach>
  
  <property name="TemplateCompile" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="${compilefiles}" />
        <include name="${AssemblyNameInfo.cs}" />
      </items>
    </in>
    <do>
      <loadfile file="${path::combine(templatedir, 'template.csproj.compile')}"
                property="tempTemplateCompile" encoding="utf-8">  
        <filterchain>
          <expandproperties />
        </filterchain>
      </loadfile>
      <property name="TemplateCompile" value="${TemplateCompile}${tempTemplateCompile}" />  
    </do>
  </foreach>
  <!-- Add the finshed project -->
  <copy file="${path::combine(templatedir, 'template.csproj')}"
        tofile="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, Namespace+'.csproj'))}" 
        overwrite="true">  
    <filterchain>
      <expandproperties />
    </filterchain>
  </copy>


</target>

</project>