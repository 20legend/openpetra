// Auto generated by nant generateGlue
// From a template at inc\template\src\ORM\ReferenceCountWebConnector.cs
//
// Do not modify this file manually!
//
{#GPLFILEHEADER}

using System;
using System.Data;
using Ict.Common;
using Ict.Common.Data;
using Ict.Common.Verification;
using Ict.Common.DB;
using Ict.Petra.Shared.MCommon;
using Ict.Petra.Shared.MCommon.Data;
using Ict.Petra.Shared.MFinance.Account.Data;
using Ict.Petra.Shared.MFinance.AP.Data;
using Ict.Petra.Shared.MFinance.Gift.Data;
using Ict.Petra.Shared.MPartner.Partner.Data;
using Ict.Petra.Shared.MPartner.Mailroom.Data;
using Ict.Petra.Shared.MPersonnel.Personnel.Data;
using Ict.Petra.Shared.MPersonnel.Units.Data;
using Ict.Petra.Shared.MConference.Data;
using Ict.Petra.Shared.MSysMan.Data;
using Ict.Petra.Server.MCommon.Data.Cascading;
using Ict.Petra.Server.MPartner.Partner.Data.Access;
using Ict.Petra.Server.MPartner.Mailroom.Data.Access;
using Ict.Petra.Server.MPersonnel.Personnel.Data.Access;
using Ict.Petra.Server.App.Core.Security;
using Ict.Petra.Server.MSysMan.Data.Access;
using Ict.Petra.Server.MFinance.Account.Data.Access;
using Ict.Petra.Server.MFinance.Gift.Data.Access;
using Ict.Petra.Server.MFinance.AP.Data.Access;
using Ict.Petra.Server.MHospitality.Data.Access;
using Ict.Petra.Server.MPersonnel.Units.Data.Access;
using Ict.Petra.Server.MConference.Data.Access;

namespace Ict.Petra.Server.M{#TOPLEVELMODULE}.ReferenceCount.WebConnectors
{
    /// <summary>
    /// DB Record-reference-counting Methods for use in the {#TOPLEVELMODULE} Module.
    /// </summary>
    public static class {#CLASSNAME}
    {
        /// <summary>
        /// Counts the records that reference a 'DataRow' of a cachable DataTable. The record count is recursive, i.e.
        /// counts all records of all related DB tables that reference the 'DataRow' AND the records that reference
        /// the record(s) of all related DB tables that reference the 'DataRow'!
        /// </summary>
        /// <param name="ACacheableTable">Tells for which cachable DataTable the records that reference a 'DataRow'
        /// of that cachable DataTable should be counted.
        /// IMPORTANT NOTE: Only tables that have a client screen with a delete button are implemented.</param>
        /// <param name="APrimaryKeyValues">Values of the Primary Key of the DataRow in question represented as an Array of object.
        /// (This can easily be obtained using the Method 'Ict.Common.Data.DataUtilities.GetPKValuesFromDataRow()'). The reason why
        /// a DataRow isn't passed for this Argument is that the 'DataRow' Class is not Serializable. </param>
        /// <param name="AMaxReferences">Use this argument to limit the time taken to search for references.
        /// A value of 0 implies no limit.  A non-zero value will return from the method when the specified number of references has been found. </param>
        /// <param name="AVerificationResult">A 'TVerificationResultCollection' containing a single
        /// 'TVerificationResult' that contains information about DB Table references created by a cascading count
        /// Method if the count yielded more than 0 referencing DataRows.</param>
        /// <returns>The number of records that reference a 'DataRow' of a cachable DataTable.</returns>
        [RequireModulePermission("NONE")]
        public static int GetCacheableRecordReferenceCount(String ACacheableTable, object[] APrimaryKeyValues, 
            int AMaxReferences, out TVerificationResultCollection AVerificationResult)
        {
            return GetCacheableRecordReferenceCount(ACacheableTable, APrimaryKeyValues, AMaxReferences, out AVerificationResult, null);
        }

        /// <summary>
        /// Counts the records that reference a 'DataRow' of a cachable DataTable. The record count is recursive, i.e.
        /// counts all records of all related DB tables that reference the 'DataRow' AND the records that reference
        /// the record(s) of all related DB tables that reference the 'DataRow'!
        /// </summary>
        /// <param name="ACacheableTable">Tells for which cachable DataTable the records that reference a 'DataRow'
        /// of that cachable DataTable should be counted.
        /// IMPORTANT NOTE: Only tables that have a client screen with a delete button are implemented.</param>
        /// <param name="APrimaryKeyValues">Values of the Primary Key of the DataRow in question represented as an Array of object.
        /// (This can easily be obtained using the Method 'Ict.Common.Data.DataUtilities.GetPKValuesFromDataRow()'). The reason why
        /// a DataRow isn't passed for this Argument is that the 'DataRow' Class is not Serializable. </param>
        /// <param name="AMaxReferences">Use this argument to limit the time taken to search for references.
        /// A value of 0 implies no limit.  A non-zero value will return from the method when the specified number of references has been found. </param>
        /// <param name="AVerificationResult">A 'TVerificationResultCollection' containing a single
        /// 'TVerificationResult' that contains information about DB Table references created by a cascading count
        /// Method if the count yielded more than 0 referencing DataRows.</param>
        /// <param name="ADataBase">An instantiated <see cref="TDataBase" /> object, or null (default = null). If null gets passed
        /// then the Method executes DB commands with the 'globally available' <see cref="DBAccess.GDBAccessObj" /> instance, otherwise with the
        /// instance that gets passed in with this Argument!</param>
        /// <returns>The number of records that reference a 'DataRow' of a cachable DataTable.</returns>
        private static int GetCacheableRecordReferenceCount(String ACacheableTable, object[] APrimaryKeyValues, 
            int AMaxReferences, out TVerificationResultCollection AVerificationResult, TDataBase ADataBase = null)
        {
            int ReturnValue = 0;

            {#CACHEABLETRANSACTION}

            try
            {
                switch (ACacheableTable)
                {
                    {#CACHEABLETABLECASES}
                    default:
                    {
                        AVerificationResult = new TVerificationResultCollection();
                        break;
                    }
                }
            }
            finally
            {
                {#CACHEABLEFINALLY}
            }

            return ReturnValue;
        }

        /// <summary>
        /// Counts the records that reference a 'DataRow' of a non-cachable DataTable. The record count is recursive, i.e.
        /// counts all records of all related DB tables that reference the 'DataRow' AND the records that reference
        /// the record(s) of all related DB tables that reference the 'DataRow'!
        /// </summary>
        /// <param name="ADataTable">Tells for which non-cachable DataTable the records that reference a 'DataRow'
        /// of that cachable DataTable should be counted.
        /// IMPORTANT NOTE: Only tables that have a client screen with a delete button are implemented.</param>
        /// <param name="APrimaryKeyValues">Values of the Primary Key of the DataRow in question represented as an Array of object.
        /// (This can easily be obtained using the Method 'Ict.Common.Data.DataUtilities.GetPKValuesFromDataRow()'). The reason why
        /// a DataRow isn't passed for this Argument is that the 'DataRow' Class is not Serializable. </param>
        /// <param name="AMaxReferences">Use this argument to limit the time taken to search for references.
        /// A value of 0 implies no limit.  A non-zero value will return from the method when the specified number of references has been found. </param>
        /// <param name="AVerificationResult">A 'TVerificationResultCollection' containing a single
        /// 'TVerificationResult' that contains information about DB Table references created by a cascading count
        /// Method if the count yielded more than 0 referencing DataRows.</param>
        /// <returns>The number of records that reference a 'DataRow' of a non-cachable DataTable.</returns>
        [RequireModulePermission("NONE")]
        public static int GetNonCacheableRecordReferenceCount(TTypedDataTable ADataTable, object[] APrimaryKeyValues,
            int AMaxReferences, out TVerificationResultCollection AVerificationResult)
        {
            return GetNonCacheableRecordReferenceCount(ADataTable, APrimaryKeyValues, AMaxReferences, out AVerificationResult, null);
        }
        
        /// <summary>
        /// Counts the records that reference a 'DataRow' of a non-cachable DataTable. The record count is recursive, i.e.
        /// counts all records of all related DB tables that reference the 'DataRow' AND the records that reference
        /// the record(s) of all related DB tables that reference the 'DataRow'!
        /// </summary>
        /// <param name="ADataTable">Tells for which non-cachable DataTable the records that reference a 'DataRow'
        /// of that cachable DataTable should be counted.
        /// IMPORTANT NOTE: Only tables that have a client screen with a delete button are implemented.</param>
        /// <param name="APrimaryKeyValues">Values of the Primary Key of the DataRow in question represented as an Array of object.
        /// (This can easily be obtained using the Method 'Ict.Common.Data.DataUtilities.GetPKValuesFromDataRow()'). The reason why
        /// a DataRow isn't passed for this Argument is that the 'DataRow' Class is not Serializable. </param>
        /// <param name="AMaxReferences">Use this argument to limit the time taken to search for references.
        /// A value of 0 implies no limit.  A non-zero value will return from the method when the specified number of references has been found. </param>
        /// <param name="AVerificationResult">A 'TVerificationResultCollection' containing a single
        /// 'TVerificationResult' that contains information about DB Table references created by a cascading count
        /// Method if the count yielded more than 0 referencing DataRows.</param>
        /// <param name="ADataBase">An instantiated <see cref="TDataBase" /> object, or null (default = null). If null gets passed
        /// then the Method executes DB commands with the 'globally available' <see cref="DBAccess.GDBAccessObj" /> instance, otherwise with the
        /// instance that gets passed in with this Argument!</param>
        /// <returns>The number of records that reference a 'DataRow' of a non-cachable DataTable.</returns>
        private static int GetNonCacheableRecordReferenceCount(TTypedDataTable ADataTable, object[] APrimaryKeyValues,
            int AMaxReferences, out TVerificationResultCollection AVerificationResult, TDataBase ADataBase = null)
        {
            int ReturnValue = 0;

            {#NONCACHEABLETRANSACTION}

            try
            {
                {#TABLESIF}
                {#TABLESELSEIF}
                {#TABLESELSE}
            }
            finally
            {
                {#NONCACHEABLEFINALLY}
            }

            return ReturnValue;
        }
    }
}

{##CACHEABLETABLECASE}
case "{#CACHEABLETABLELISTNAME}":
{
    ReturnValue = {#CACHEABLETABLENAME}Cascading.CountByPrimaryKey(APrimaryKeyValues, AMaxReferences,
        ReadTransaction, true, out AVerificationResult);
    break;
}

{##TABLEIF}
if (ADataTable is {#TABLENAME}Table)
{
    ReturnValue = {#TABLENAME}Cascading.CountByPrimaryKey(APrimaryKeyValues, AMaxReferences, ReadTransaction, true, out AVerificationResult);
}

{##TABLEELSEIF}
else if (ADataTable is {#TABLENAME}Table)
{
    ReturnValue = {#TABLENAME}Cascading.CountByPrimaryKey(APrimaryKeyValues, AMaxReferences, ReadTransaction, true, out AVerificationResult);
}

{##TABLEELSE}
else
{
    AVerificationResult = new TVerificationResultCollection();
}

{##TABLENONE}
AVerificationResult = new TVerificationResultCollection();

{##CACHEABLETRANSACTIONSNIP}
Boolean NewTransaction;
TDBTransaction ReadTransaction = DBAccess.GetDBAccessObj(ADataBase).GetNewOrExistingTransaction(
    MCommonConstants.CACHEABLEDT_ISOLATIONLEVEL,
    TEnforceIsolationLevel.eilMinimum,
    out NewTransaction);

{##NONCACHEABLETRANSACTIONSNIP}
Boolean NewTransaction;
TDBTransaction ReadTransaction = DBAccess.GetDBAccessObj(ADataBase).GetNewOrExistingTransaction(
    IsolationLevel.ReadCommitted,
    TEnforceIsolationLevel.eilMinimum,
    out NewTransaction);

{##CACHEABLEFINALLYSNIP}
if (NewTransaction)
{
    DBAccess.GetDBAccessObj(ADataBase).CommitTransaction();
    TLogging.LogAtLevel(9, ACacheableTable + ": GetCacheableRecordReferenceCount: committed own transaction.");
}

{##NONCACHEABLEFINALLYSNIP}
if (NewTransaction)
{
    DBAccess.GetDBAccessObj(ADataBase).CommitTransaction();
    TLogging.LogAtLevel(9, ADataTable.TableName + ": GetNonCacheableRecordReferenceCount: committed own transaction.");
}
