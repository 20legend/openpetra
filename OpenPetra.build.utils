<?xml version="1.0"?>
<!-- this contains the csharp functions that are used in OpenPetra.build -->
<project name="OpenPetra" default="help">
    <script language="C#">
		<references>
		  <include name="System.dll" />
        </references>
		<imports>
          <import namespace="System.Text.RegularExpressions" />
        </imports>    
        <code>
        <![CDATA[
    [Function("ReplaceInFile")]
    public static bool ReplaceInFile(string filename, string oldValue, string newValue)
    {
      String line = "start";
      StreamReader sr = new StreamReader(filename);
      StreamWriter sw = new StreamWriter(filename + ".new");
      bool doRegExpr = false;
      if (oldValue.StartsWith("RegEx:"))
      {
        doRegExpr = true;
        oldValue = oldValue.Substring("RegEx:".Length);
      }
      bool firstLine = true;
      while (line != null)
      {
        line = sr.ReadLine();
        if (line != null)
        {
            if (!firstLine)
            {
                // for uncrustify we have no linebreak on the last line
                sw.WriteLine();
            }
            firstLine = false;
            if (doRegExpr)
            {
                Regex reg=new Regex(oldValue);
                line=reg.Replace(line,newValue);
            }
            else
            {
                line = line.Replace(oldValue, newValue);
            }
            
            sw.Write(line);
        }
      }
      sr.Close();
      sw.Close();
      File.Delete(filename);
      File.Move(filename + ".new", filename);
      return true;
    }

    [System.Runtime.InteropServices.DllImport("kernel32.dll")]
    static extern uint QueryDosDevice(string lpDeviceName, StringBuilder lpTargetPath, int ucc);

	// this will reverse the effect of the MSDOS subst command, ie a locally mapped network drive will be mapped back to the real path behind it
	// see also http://bloggingabout.net/blogs/ramon/archive/2007/04/05/get-the-physical-path-of-a-path-that-uses-a-subst-drive.aspx
    [Function("GetRealPath")]
	public static string GetRealPath(string path)
    {
        const int BUFFER_LENGTH = 1024;

        if (Directory.Exists(path))
        {
            path = new DirectoryInfo(path).FullName;
        }
        else if (File.Exists(path))
        {
            path = new FileInfo(path).FullName;
        }

        StringBuilder pathInformation = new StringBuilder(BUFFER_LENGTH);
        QueryDosDevice(path.Substring(0,2), pathInformation, BUFFER_LENGTH);

        // If drive is substed, the result will be in the format of "\??\C:\RealPath\".
        // after that strip the \??\ prefix and combine the paths.
        if (pathInformation.ToString().Contains(@"\??\"))
        {
            return pathInformation.ToString(4, pathInformation.Length-4) + path.Substring(2); // Remove the drive letter
        }

        return path;
    }
	
    [Function("GetFilenameWithoutExtension")]
    public static string GetFilenameWithoutExtension(string filename)
    {
      return System.IO.Path.GetFileNameWithoutExtension(filename);
    }
    
    [Function("GetDesignerFilename")]
    public static string GetDesignerFilename(string AFilename)
    {
      return Path.GetDirectoryName(AFilename) + Path.DirectorySeparatorChar + System.IO.Path.GetFileNameWithoutExtension(AFilename) + ".Designer.cs";
    }

    [Function("IsAutoGeneratedFile")]
    public static bool IsAutoGeneratedFile(string filename)
    {
      StreamReader sr = new StreamReader(filename);
      string line = sr.ReadLine();
      sr.Close();
      return line.ToLower().IndexOf("auto generated with nant") != -1;
    }

    [Function("CheckCode")]
    public static bool CheckCode(string filename)
    {
      bool fileOK = true;
      StreamReader sr = new StreamReader(filename);
      string line = sr.ReadToEnd();
      sr.Close();
      // todo: more checks; eg. file header, licensing, copyright;
      
      // check for xml comments written during compilation
      if (filename.EndsWith(".csproj") && line.IndexOf("<DocumentationFile>") == -1)
      {
        fileOK = false;
        Console.WriteLine("Project {0} does not write XML comments for NDoc", System.IO.Path.GetFileName(filename));
      }
      return fileOK;
    }

	/// Count the lines of code of all cs and yaml files, but disregard designer files, and generated files;
	/// ignores comments and empty lines
    [Function("CountLinesOfCode")]
    public static Int32 CountLinesOfCode(string ARootDirectory)
    {
		Int32 CountLines = 0;

		string[] files = System.IO.Directory.GetFiles(ARootDirectory, "*.cs", SearchOption.AllDirectories);

		foreach (string filename in files)
		{
			if (!filename.EndsWith(".Designer.cs") 
				&& filename.IndexOf("AssemblyInfo") == -1 
				&& filename.IndexOf("CollectedGettext") == -1 
				&& filename.IndexOf("Testing") == -1 
				&& filename.IndexOf("experimenting") == -1)
			{
				StreamReader reader = new StreamReader(filename);
				
				string line = reader.ReadLine();
				bool insideCommentBlock = false;
				
				if (line.ToLower().IndexOf("auto generated with nant") == -1)
				{
					//Console.WriteLine(filename);
					while (!reader.EndOfStream)
					{
						line = reader.ReadLine().Trim();
						if (line.StartsWith("//") || (line.StartsWith("/*") && line.EndsWith("*/")))
						{
							continue;
						}

						if (line.IndexOf("/*") > -1 && line.IndexOf("*/") == -1)
						{
							insideCommentBlock = true;
							continue;
						}
						else if (line.IndexOf("*/") > -1)
						{
							insideCommentBlock = false;
							continue;
						}
						
						if (!insideCommentBlock && line.Length > 0)
						{
							CountLines++;
						}
					}
				}
				reader.Close();
			}
		}
		
		files = System.IO.Directory.GetFiles(ARootDirectory, "*.yaml", SearchOption.AllDirectories);

		foreach (string filename in files)
		{
			//Console.WriteLine(filename);
			StreamReader reader = new StreamReader(filename);
			
			string line = reader.ReadLine();

			while (!reader.EndOfStream)
			{
				line = reader.ReadLine().Trim();
				if (line.StartsWith("#"))
				{
					continue;
				}

				if (line.Length > 0)
				{
					CountLines++;
				}
			}
			
			reader.Close();
		}
						
		return CountLines;
	}

	private static Int32 CountPhysicalLinesOfFiles(string ARootDirectory, string ASearchPattern)
	{
		Int32 CountLines = 0;
		string[] files = System.IO.Directory.GetFiles(ARootDirectory, ASearchPattern, SearchOption.AllDirectories);

		foreach (string filename in files)
		{
			if (filename.IndexOf(".yaml.xml") == -1
				&& filename.IndexOf(Path.DirectorySeparatorChar + "_bin" + Path.DirectorySeparatorChar) == -1)
			{
				//Console.WriteLine(filename);
				StreamReader reader = new StreamReader(filename);
				
				string line = reader.ReadLine();
				bool insideCommentBlock = false;
					
				while (!reader.EndOfStream)
				{
					line = reader.ReadLine().Trim();

					if (line.StartsWith("//") || (line.StartsWith("/*") && line.EndsWith("*/")))
					{
						continue;
					}

					if (line.IndexOf("/*") > -1 && line.IndexOf("*/") == -1)
					{
						insideCommentBlock = true;
						continue;
					}
					else if (line.IndexOf("*/") > -1)
					{
						insideCommentBlock = false;
						continue;
					}
					
					if (!insideCommentBlock && line.Length > 0)
					{
						CountLines++;
					}
				}
				reader.Close();
			}
		}
		
		return CountLines;
	}
	
	/// count all lines of code, no matter if empty line, comment, file type etc
	[Function("CountPhysicalLinesOfCode")]
    public static Int32 CountPhysicalLinesOfCode(string ARootDirectory)
    {
		Int32 CountLines = 0;
		
		CountLines += CountPhysicalLinesOfFiles(ARootDirectory, "*.cs");
		//CountLines += CountPhysicalLinesOfFiles(ARootDirectory, "*.yaml");
		//CountLines += CountPhysicalLinesOfFiles(ARootDirectory, "*.resx");
		//CountLines += CountPhysicalLinesOfFiles(ARootDirectory, "*.xml");

		return CountLines;
	}

    [Function("CalculateRPMVersionFromDLLVersion")]
    public static string CalculateRPMVersionFromDLLVersion(string AReleaseID)
    {
		// AReleaseVersion comes in this format: 0.0.99.1
		// result should be: 0.0.99-1
		string[] versionnumbers = AReleaseID.Split(new char[]{'.'});
		if (versionnumbers.Length != 4)
		{
			throw new Exception("Problem with version numbers: " + AReleaseID);
		}
        return versionnumbers[0] + "." + versionnumbers[1] + "." + versionnumbers[2] + "-" + versionnumbers[3];
	}
	
    [Function("GetMainVersionWithoutBuildNr")]
    public static string GetMainVersionWithoutBuildNr(string AReleaseVersion)
    {
        return AReleaseVersion.Substring(0, AReleaseVersion.IndexOf("-"));
    }

    [Function("ChangeProjectFileXBuild")]
    public static bool ChangeProjectFileXBuild(string filename)
    {
        ReplaceInFile(filename, "RegEx:<HintPath>.*ThirdParty.*Mono.*dll</HintPath>", "");
        ReplaceInFile(filename, "RegEx:<HintPath>.*ThirdParty.*ICSharpCode.*dll</HintPath>", "");
        ReplaceInFile(filename, "RegEx:<HintPath>.*ThirdParty.*nunit.*dll</HintPath>", "");

        //hide warnings: 
        // warning CS0169:  The private method / property / etc is never used
        // warning CS0219:  The variable xyz is assigned but its value is never used
        // warning CS0414:  The private field xyz is assigned but its value is never used
        // warning CS0067:  The event xyz is never used
        // it seems you need to change the file /usr/lib/mono/2.0/Microsoft.CSharp.targets as well, it should read:  DisabledWarnings="$(NoWarn)"
        // see also http://lists.ximian.com/archives/public/mono-patches/2009-December/163612.html
        ReplaceInFile(filename, 
                      "</PropertyGroup>", 
                      "<NoWarn>0169,0219,0414,0067</NoWarn></PropertyGroup>");
        return true;
    }

    [Function("ReplaceFileHeader")]
    public static bool ReplaceHeader(string filename)
    {
      Console.WriteLine(filename);
      String line = "start";
      StreamReader sr = new StreamReader(filename);
      StreamWriter sw = new StreamWriter(filename + ".new");
      bool firstLine = true;
      while (line != null)
      {
        line = sr.ReadLine();
        if (line != null)
        {
            if (line == "/*************************************************************************")
            {
                line = sr.ReadLine();

                while (!line.EndsWith("************************************************************************/"))
                {
                    
                    if (line.StartsWith(" *"))
                    {
                        line = "//" + line.Substring(2);
                    }
                    
                    line = line.Replace("2004-2009 by OM International", "2004-2010 by OM International");
                    
                    sw.WriteLine(line);
                    
                    line = sr.ReadLine();
                }
                
                line = sr.ReadLine();
            }

            if (!firstLine)
            {
                // for uncrustify we have no linebreak on the last line
                sw.WriteLine();
            }
            firstLine = false;
            
            line = line.Replace("(c) OM International 2004-2009", "(c) OM International 2004-2010");

            sw.Write(line);
        }
      }
      sr.Close();
      sw.Close();
      File.Delete(filename);
      File.Move(filename + ".new", filename);
      return true;
    }
    
    
    [Function("ChangeProjectFileRelease")]
    public static bool ChangeProjectFileRelease(string filename, bool makerelease)
    {
        if (makerelease)
        {
            if (!System.IO.File.Exists(filename + ".origDebug"))
            {
                System.IO.File.Copy(filename, filename + ".origDebug");
            }
            ReplaceInFile(filename, "_bin\\Debug", "_bin\\Release");
            ReplaceInFile(filename, "Server_Client\\Debug", "Server_Client\\Release");
            ReplaceInFile(filename, "Server_ServerAdmin\\Debug", "Server_ServerAdmin\\Release");
            ReplaceInFile(filename, "_bin/Debug", "_bin/Release");
            ReplaceInFile(filename, "Server_Client/Debug", "Server_Client/Release");
            ReplaceInFile(filename, "Server_ServerAdmin/Debug", "Server_ServerAdmin/Release");

            // we need to compile for 32 bit, otherwise there is a problem with the Mono.Posix.dll
            // see also http://sourceforge.net/apps/mantisbt/openpetraorg/view.php?id=116
            ReplaceInFile(filename, "RegEx:<PlatformTarget>.*</PlatformTarget>", "<PlatformTarget>x86</PlatformTarget>");
        }
        else
        {
            if (System.IO.File.Exists(filename + ".origDebug"))
            {
                System.IO.File.Delete(filename);
                System.IO.File.Move(filename + ".origDebug", filename);
            }
        }
        return true;
    }

    [Function("ChangeAssemblyVersion")]
    public static bool ChangeAssemblyVersion(string filename, string releaseID, bool makerelease)
    {
        if (makerelease)
        {
            if (!System.IO.File.Exists(filename + ".origDebug"))
            {
                System.IO.File.Copy(filename, filename + ".origDebug");
            }
            ReplaceInFile(filename, "RegEx:AssemblyVersion(.*)]", "AssemblyVersion(\"" + releaseID + "\")]");
        }
        else
        {
            if (System.IO.File.Exists(filename + ".origDebug"))
            {
                System.IO.File.Delete(filename);
                System.IO.File.Move(filename + ".origDebug", filename);
            }
        }
        return true;
    }

    [Function("AddProject")]
    public static string AddProject(string ATemplatePath, string ASolutionFile, string AProjectFile, string ANamespace)
    {
        // determine the template that should be used
        string template = String.Empty;
        string solutionHomeRef = String.Empty;

        if (ANamespace.StartsWith("Tests.") || ANamespace.StartsWith("Ict.Testing."))
        {
            template = "nunit.csproj";
            solutionHomeRef = "ICT/Testing/";
        }
        else if (ANamespace.StartsWith("Ict.Petra.Client."))
        {
            template = "client.csproj";
            solutionHomeRef = "ICT/Petra/Client/";
        }
        else if (ANamespace.StartsWith("Ict.Petra.Server."))
        {
            template = "server.csproj";
            solutionHomeRef = "ICT/Petra/Server/";
        }
        else if (ANamespace.StartsWith("Ict.Petra.Shared."))
        {
            template = "shared.csproj";
            solutionHomeRef = "ICT/Petra/Shared/";
        }
        else if (ANamespace.StartsWith("ClientPlugin."))
        {
            template = "clientplugin.csproj";
            solutionHomeRef = "ICT/Petra/ClientPlugins/";
        }
        else if (ANamespace.StartsWith("ServerPlugin."))
        {
            template = "serverplugin.csproj";
            solutionHomeRef = "ICT/Petra/ServerPlugins/";
        }
        else if (ANamespace.StartsWith("Ict.Tools."))
        {
            template = "petratools.csproj";
            solutionHomeRef = "ICT/PetraTools/";
        }

        if (template == String.Empty)
        {
            throw new Exception("There is no automatic way to create project files for this namespace yet");
        }

        // calculate path from the project file to the solution home, which is the parent of _bin/Debug etc
        AProjectFile = AProjectFile.Replace("\\", "/");
        string pathFromSolutionRef = AProjectFile.Substring(AProjectFile.IndexOf(solutionHomeRef) + solutionHomeRef.Length);
        int countSlashes = pathFromSolutionRef.Length - pathFromSolutionRef.Replace("/", "").Length;
        string solutionHomeRelPath = String.Empty;
        for (int counter = 0; counter < countSlashes; counter++)
        {
            solutionHomeRelPath = solutionHomeRelPath + "../";
        }

        // copy will fail if project file already exists. that saves us from more complications
        System.IO.File.Copy(ATemplatePath + template, AProjectFile);
        string ProjectGUID = Guid.NewGuid().ToString().ToUpper();
        ReplaceInFile(AProjectFile, "{#PROJECTGUID}", ProjectGUID);
        ReplaceInFile(AProjectFile, "{#NAMESPACE}", ANamespace);
        if (solutionHomeRelPath.EndsWith("/"))
        {
            ReplaceInFile(AProjectFile, "{#SOLUTIONHOME}/", solutionHomeRelPath);
        }
        ReplaceInFile(AProjectFile, "{#SOLUTIONHOME}", solutionHomeRelPath);

        // create assembly file
        System.IO.File.Copy(ATemplatePath + "AssemblyInfo.cs", AProjectFile.Replace(".csproj", ".AssemblyInfo.cs"));
        ReplaceInFile(AProjectFile.Replace(".csproj", ".AssemblyInfo.cs"), "{#NAMESPACE}", ANamespace);

        // add some initial files depending on type of dll
        if (template == "nunit.csproj")
        {
            System.IO.File.Copy(ATemplatePath + "nunit.cs", AProjectFile.Replace(".csproj", ".Test.cs"));
            ReplaceInFile(AProjectFile, "<Compile Include=\"" + ANamespace + ".AssemblyInfo.cs\" />", 
                    "<Compile Include=\"" + ANamespace + ".AssemblyInfo.cs\" />" + Environment.NewLine +
                    "    <Compile Include=\"" + ANamespace + ".Test.cs\" />");
            ReplaceInFile(AProjectFile.Replace(".csproj", ".Test.cs"), "{#NAMESPACE}", ANamespace);
        }

        // add to solution
        ReplaceInFile(ASolutionFile, "RegEx:^Global",
                "Project(\"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\") = \"" + ANamespace + "\", \"" + 
                AProjectFile.Substring(AProjectFile.IndexOf("csharp/ICT/") + ("csharp/ICT/").Length).Replace("/", "\\") + 
                "\", \"{" + ProjectGUID + "}\"" + Environment.NewLine +
                "EndProject" + Environment.NewLine + 
                "Global");

        return AProjectFile + " has been created successfully and was added to the solution";
    }

    [Function("CalculateStandaloneDBUpdateFileName")]
    public static string CalculateStandaloneDBUpdateFileName(string ReleaseID)
    {
        string[] numbers = ReleaseID.Split(new char[]{'.', '-'});
        
        // need to manually code the medium version increases
        if (numbers[1] == "1" && numbers[2] == "0")
        {
            return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                            0, 0, 15,
                            numbers[0], numbers[1], numbers[2]);
        }

        if (numbers[1] == "2" && numbers[2] == "0")
        {
            return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                            0, 1, 0,
                            numbers[0], numbers[1], numbers[2]);
        }

        // this is for smaller patches
        return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                            numbers[0], numbers[1], Convert.ToInt16(numbers[2]) - 1,
                            numbers[0], numbers[1], numbers[2]);
    }
    ]]>
        </code>
    </script>    
    <script language="C#">
          <references>
              <include name="System.Web.dll" />
          </references>
          <imports>
              <import namespace="System.Web.Security" />
              <import namespace="System.Security.Cryptography" />
          </imports>    
          <code>
            <![CDATA[
              [Function("GetPasswordSalt")]
              public static string GetPasswordSalt() {
                    //Generate a cryptographic random number.
                    RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
                    byte[] buff = new byte[32];
                    rng.GetBytes(buff);

                    // Return a Base64 string representation of the random number.
                    return Convert.ToBase64String(buff);
              }
              [Function("GetPasswordHash")]
              public static string GetPasswordHash(string APassword, string ASalt) {
                  return FormsAuthentication.HashPasswordForStoringInConfigFile(String.Concat(APassword, ASalt), "SHA1"); 
              }
            ]]>
          </code>
    </script>    
</project>